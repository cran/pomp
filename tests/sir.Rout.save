
R version 2.11.1 (2010-05-31)
Copyright (C) 2010 The R Foundation for Statistical Computing
ISBN 3-900051-07-0

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(pomp)
> 
> tbasis <- seq(0,25,by=1/52)
> basis <- periodic.bspline.basis(tbasis,nbasis=3)
> colnames(basis) <- paste("seas",1:3,sep='')
> 
> ## some parameters
> params <- c(
+             gamma=26,mu=0.02,iota=0.01,
+             beta1=1200,beta2=1800,beta3=600,
+             beta.sd=1e-3,
+             pop=2.1e6,
+             rho=0.6,
+             S.0=26/1200,I.0=0.001,R.0=1-0.001-26/1200
+             )
> 
> ## set up the pomp object
> ## the C codes "sir_euler_simulator" and "sir_euler_density" are included in the "examples" directory (file "sir.c")
> po <- pomp(
+            times=1/52*seq.int(length=4*52),
+            data=rbind(reports=numeric(52*4)),
+            t0=0,
+            tcovar=tbasis,
+            covar=basis,
+            zeronames=c("cases"),
+            rprocess=euler.sim(
+              delta.t=1/52/20,
+              step.fun=function(t,x,params,covars,delta.t,...) {
+                params <- exp(params)
+                with(
+                     as.list(c(x,params)),
+                     {
+                       beta <- exp(sum(log(c(beta1,beta2,beta3))*covars))
+                       beta.var <- beta.sd^2
+                       dW <- rgamma(n=1,shape=delta.t/beta.var,scale=beta.var)
+                       foi <- (iota+beta*I*dW/delta.t)/pop
+                       trans <- c(
+                                  rpois(n=1,lambda=mu*pop*delta.t),
+                                  reulermultinom(n=1,size=S,rate=c(foi,mu),dt=delta.t),
+                                  reulermultinom(n=1,size=I,rate=c(gamma,mu),dt=delta.t),
+                                  reulermultinom(n=1,size=R,rate=c(mu),dt=delta.t)
+                                  )
+                       c(
+                         S=S+trans[1]-trans[2]-trans[3],
+                         I=I+trans[2]-trans[4]-trans[5],
+                         R=R+trans[4]-trans[6],
+                         cases=cases+trans[4],
+                         W=if (beta.sd>0) W+(dW-delta.t)/beta.sd else W,
+                         B=trans[1],
+                         SI=trans[2],
+                         SD=trans[3],
+                         IR=trans[4],
+                         ID=trans[5],
+                         RD=trans[6],
+                         dW=dW
+                         )
+                     }
+                     )
+              }
+              ),
+            dprocess=onestep.dens(
+              dens.fun=function(t1,t2,params,x1,x2,covars,...) {
+                params <- exp(params)
+                with(
+                     as.list(params),
+                     {
+                       dt <- t2-t1
+                       beta <- exp(sum(log(c(beta1,beta2,beta3))*covars))
+                       beta.var <- beta.sd^2
+                       dW <- x2['dW']
+                       foi <- (iota+beta*x1["I"]*dW/dt)/pop
+                       probs <- c(
+                                  dpois(x=x2["B"],lambda=mu*pop*dt,log=T),
+                                  deulermultinom(x=x2[c("SI","SD")],size=x1["S"],rate=c(foi,mu),dt=dt,log=T),
+                                  deulermultinom(x=x2[c("IR","ID")],size=x1["I"],rate=c(gamma,mu),dt=dt,log=T),
+                                  deulermultinom(x=x2["RD"],size=x1["R"],rate=c(mu),dt=dt,log=T),
+                                  dgamma(x=dW,shape=dt/beta.var,scale=beta.var,log=T)
+                                  )
+                       sum(probs)
+                     }
+                     )
+              }
+              ),
+            skeleton.vectorfield=function(x,t,params,covars,...) {
+              xdot <- rep(0,length(x))
+              params <- exp(params)
+              with(
+                   as.list(c(x,params)),
+                   {
+                     beta <- exp(sum(log(c(beta1,beta2,beta3))*covars))
+                     foi <- (iota+beta*I)/pop
+                     terms <- c(
+                                mu*pop,
+                                foi*S,
+                                mu*S,
+                                gamma*I,
+                                mu*I,
+                                mu*R
+                                )
+                     xdot[1:4] <- c(
+                                    terms[1]-terms[2]-terms[3],
+                                    terms[2]-terms[4]-terms[5],
+                                    terms[4]-terms[6],
+                                    terms[4]
+                                    )
+                     xdot
+                   }
+                   )
+            },
+            measurement.model=reports~binom(size=cases,prob=exp(rho)),
+            initializer=function(params,t0,...){
+              p <- exp(params)
+              with(
+                   as.list(p),
+                   {
+                     fracs <- c(S.0,I.0,R.0)
+                     x0 <- c(
+                             round(pop*fracs/sum(fracs)), # make sure the three compartments sum to 'pop' initially
+                             rep(0,9)	# zeros for 'cases', 'W', and the transition numbers
+                             )
+                     names(x0) <- c("S","I","R","cases","W","B","SI","SD","IR","ID","RD","dW")
+                     x0
+                   }
+                   )
+            }
+            )
> 
> show(po)
data and states:
          time reports
1   0.01923077       0
2   0.03846154       0
3   0.05769231       0
4   0.07692308       0
5   0.09615385       0
6   0.11538462       0
7   0.13461538       0
8   0.15384615       0
9   0.17307692       0
10  0.19230769       0
11  0.21153846       0
12  0.23076923       0
13  0.25000000       0
14  0.26923077       0
15  0.28846154       0
16  0.30769231       0
17  0.32692308       0
18  0.34615385       0
19  0.36538462       0
20  0.38461538       0
21  0.40384615       0
22  0.42307692       0
23  0.44230769       0
24  0.46153846       0
25  0.48076923       0
26  0.50000000       0
27  0.51923077       0
28  0.53846154       0
29  0.55769231       0
30  0.57692308       0
31  0.59615385       0
32  0.61538462       0
33  0.63461538       0
34  0.65384615       0
35  0.67307692       0
36  0.69230769       0
37  0.71153846       0
38  0.73076923       0
39  0.75000000       0
40  0.76923077       0
41  0.78846154       0
42  0.80769231       0
43  0.82692308       0
44  0.84615385       0
45  0.86538462       0
46  0.88461538       0
47  0.90384615       0
48  0.92307692       0
49  0.94230769       0
50  0.96153846       0
51  0.98076923       0
52  1.00000000       0
53  1.01923077       0
54  1.03846154       0
55  1.05769231       0
56  1.07692308       0
57  1.09615385       0
58  1.11538462       0
59  1.13461538       0
60  1.15384615       0
61  1.17307692       0
62  1.19230769       0
63  1.21153846       0
64  1.23076923       0
65  1.25000000       0
66  1.26923077       0
67  1.28846154       0
68  1.30769231       0
69  1.32692308       0
70  1.34615385       0
71  1.36538462       0
72  1.38461538       0
73  1.40384615       0
74  1.42307692       0
75  1.44230769       0
76  1.46153846       0
77  1.48076923       0
78  1.50000000       0
79  1.51923077       0
80  1.53846154       0
81  1.55769231       0
82  1.57692308       0
83  1.59615385       0
84  1.61538462       0
85  1.63461538       0
86  1.65384615       0
87  1.67307692       0
88  1.69230769       0
89  1.71153846       0
90  1.73076923       0
91  1.75000000       0
92  1.76923077       0
93  1.78846154       0
94  1.80769231       0
95  1.82692308       0
96  1.84615385       0
97  1.86538462       0
98  1.88461538       0
99  1.90384615       0
100 1.92307692       0
101 1.94230769       0
102 1.96153846       0
103 1.98076923       0
104 2.00000000       0
105 2.01923077       0
106 2.03846154       0
107 2.05769231       0
108 2.07692308       0
109 2.09615385       0
110 2.11538462       0
111 2.13461538       0
112 2.15384615       0
113 2.17307692       0
114 2.19230769       0
115 2.21153846       0
116 2.23076923       0
117 2.25000000       0
118 2.26923077       0
119 2.28846154       0
120 2.30769231       0
121 2.32692308       0
122 2.34615385       0
123 2.36538462       0
124 2.38461538       0
125 2.40384615       0
126 2.42307692       0
127 2.44230769       0
128 2.46153846       0
129 2.48076923       0
130 2.50000000       0
131 2.51923077       0
132 2.53846154       0
133 2.55769231       0
134 2.57692308       0
135 2.59615385       0
136 2.61538462       0
137 2.63461538       0
138 2.65384615       0
139 2.67307692       0
140 2.69230769       0
141 2.71153846       0
142 2.73076923       0
143 2.75000000       0
144 2.76923077       0
145 2.78846154       0
146 2.80769231       0
147 2.82692308       0
148 2.84615385       0
149 2.86538462       0
150 2.88461538       0
151 2.90384615       0
152 2.92307692       0
153 2.94230769       0
154 2.96153846       0
155 2.98076923       0
156 3.00000000       0
157 3.01923077       0
158 3.03846154       0
159 3.05769231       0
160 3.07692308       0
161 3.09615385       0
162 3.11538462       0
163 3.13461538       0
164 3.15384615       0
165 3.17307692       0
166 3.19230769       0
167 3.21153846       0
168 3.23076923       0
169 3.25000000       0
170 3.26923077       0
171 3.28846154       0
172 3.30769231       0
173 3.32692308       0
174 3.34615385       0
175 3.36538462       0
176 3.38461538       0
177 3.40384615       0
178 3.42307692       0
179 3.44230769       0
180 3.46153846       0
181 3.48076923       0
182 3.50000000       0
183 3.51923077       0
184 3.53846154       0
185 3.55769231       0
186 3.57692308       0
187 3.59615385       0
188 3.61538462       0
189 3.63461538       0
190 3.65384615       0
191 3.67307692       0
192 3.69230769       0
193 3.71153846       0
194 3.73076923       0
195 3.75000000       0
196 3.76923077       0
197 3.78846154       0
198 3.80769231       0
199 3.82692308       0
200 3.84615385       0
201 3.86538462       0
202 3.88461538       0
203 3.90384615       0
204 3.92307692       0
205 3.94230769       0
206 3.96153846       0
207 3.98076923       0
208 4.00000000       0

call:
pomp(data = rbind(reports = numeric(52 * 4)), times = 1/52 * 
    seq.int(length = 4 * 52), t0 = 0, zeronames = c("cases"), 
    rprocess = euler.sim(delta.t = 1/52/20, step.fun = function(t, 
        x, params, covars, delta.t, ...) {
        params <- exp(params)
        with(as.list(c(x, params)), {
            beta <- exp(sum(log(c(beta1, beta2, beta3)) * covars))
            beta.var <- beta.sd^2
            dW <- rgamma(n = 1, shape = delta.t/beta.var, scale = beta.var)
            foi <- (iota + beta * I * dW/delta.t)/pop
            trans <- c(rpois(n = 1, lambda = mu * pop * delta.t), 
                reulermultinom(n = 1, size = S, rate = c(foi, 
                  mu), dt = delta.t), reulermultinom(n = 1, size = I, 
                  rate = c(gamma, mu), dt = delta.t), reulermultinom(n = 1, 
                  size = R, rate = c(mu), dt = delta.t))
            c(S = S + trans[1] - trans[2] - trans[3], I = I + 
                trans[2] - trans[4] - trans[5], R = R + trans[4] - 
                trans[6], cases = cases + trans[4], W = if (beta.sd > 
                0) W + (dW - delta.t)/beta.sd else W, B = trans[1], 
                SI = trans[2], SD = trans[3], IR = trans[4], 
                ID = trans[5], RD = trans[6], dW = dW)
        })
    }), dprocess = onestep.dens(dens.fun = function(t1, t2, params, 
        x1, x2, covars, ...) {
        params <- exp(params)
        with(as.list(params), {
            dt <- t2 - t1
            beta <- exp(sum(log(c(beta1, beta2, beta3)) * covars))
            beta.var <- beta.sd^2
            dW <- x2["dW"]
            foi <- (iota + beta * x1["I"] * dW/dt)/pop
            probs <- c(dpois(x = x2["B"], lambda = mu * pop * 
                dt, log = T), deulermultinom(x = x2[c("SI", "SD")], 
                size = x1["S"], rate = c(foi, mu), dt = dt, log = T), 
                deulermultinom(x = x2[c("IR", "ID")], size = x1["I"], 
                  rate = c(gamma, mu), dt = dt, log = T), deulermultinom(x = x2["RD"], 
                  size = x1["R"], rate = c(mu), dt = dt, log = T), 
                dgamma(x = dW, shape = dt/beta.var, scale = beta.var, 
                  log = T))
            sum(probs)
        })
    }), measurement.model = reports ~ binom(size = cases, prob = exp(rho)), 
    skeleton.vectorfield = function(x, t, params, covars, ...) {
        xdot <- rep(0, length(x))
        params <- exp(params)
        with(as.list(c(x, params)), {
            beta <- exp(sum(log(c(beta1, beta2, beta3)) * covars))
            foi <- (iota + beta * I)/pop
            terms <- c(mu * pop, foi * S, mu * S, gamma * I, 
                mu * I, mu * R)
            xdot[1:4] <- c(terms[1] - terms[2] - terms[3], terms[2] - 
                terms[4] - terms[5], terms[4] - terms[6], terms[4])
            xdot
        })
    }, initializer = function(params, t0, ...) {
        p <- exp(params)
        with(as.list(p), {
            fracs <- c(S.0, I.0, R.0)
            x0 <- c(round(pop * fracs/sum(fracs)), rep(0, 9))
            names(x0) <- c("S", "I", "R", "cases", "W", "B", 
                "SI", "SD", "IR", "ID", "RD", "dW")
            x0
        })
    }, covar = basis, tcovar = tbasis)
zero time, t0 = 0
parameter(s) unspecified
process model simulator, rprocess = 
function (xstart, times, params, ..., statenames = character(0), 
    paramnames = character(0), covarnames = character(0), zeronames = character(0), 
    tcovar, covar) 
{
    .Call(euler_model_simulator, func = efun, xstart = xstart, 
        times = times, params = params, dt = delta.t, method = 0L, 
        statenames = statenames, paramnames = paramnames, covarnames = covarnames, 
        zeronames = zeronames, tcovar = tcovar, covar = covar, 
        args = pairlist(...))
}
<environment: 0x2633e80>
process model density, dprocess = 
function (x, times, params, ..., statenames = character(0), paramnames = character(0), 
    covarnames = character(0), tcovar, covar, log = FALSE) 
{
    .Call(euler_model_density, func = efun, x = x, times = times, 
        params = params, statenames = statenames, paramnames = paramnames, 
        covarnames = covarnames, tcovar = tcovar, covar = covar, 
        log = log, args = pairlist(...))
}
<environment: 0x2ca6dd0>
measurement model simulator, rmeasure = 
function (x, t, params, covars, ...) 
{
    y <- numeric(length = nobs)
    names(y) <- obsnames
    for (k in seq_len(nobs)) {
        y[k] <- eval(rcalls[[k]], envir = as.list(c(x, params, 
            covars, t = t)))
    }
    y
}
<environment: 0x2c3f9d0>
measurement model density, dmeasure = 
function (y, x, t, params, log, covars, ...) 
{
    f <- 0
    for (k in seq_len(nobs)) {
        f <- f + eval(dcalls[[k]], envir = as.list(c(y, x, params, 
            covars, t = t)))
    }
    if (log) 
        f
    else exp(f)
}
<environment: 0x2c3f9d0>
skeleton ( vectorfield ) = 
function (x, t, params, covars, ...) 
{
    xdot <- rep(0, length(x))
    params <- exp(params)
    with(as.list(c(x, params)), {
        beta <- exp(sum(log(c(beta1, beta2, beta3)) * covars))
        foi <- (iota + beta * I)/pop
        terms <- c(mu * pop, foi * S, mu * S, gamma * I, mu * 
            I, mu * R)
        xdot[1:4] <- c(terms[1] - terms[2] - terms[3], terms[2] - 
            terms[4] - terms[5], terms[4] - terms[6], terms[4])
        xdot
    })
}
initializer = 
function (params, t0, ...) 
{
    p <- exp(params)
    with(as.list(p), {
        fracs <- c(S.0, I.0, R.0)
        x0 <- c(round(pop * fracs/sum(fracs)), rep(0, 9))
        names(x0) <- c("S", "I", "R", "cases", "W", "B", "SI", 
            "SD", "IR", "ID", "RD", "dW")
        x0
    })
}
userdata = 
$zeronames
[1] "cases"

> 
> set.seed(3049953)
> ## simulate from the model
> tic <- Sys.time()
> x <- simulate(po,params=log(params),nsim=3)
> toc <- Sys.time()
> print(toc-tic)
Time difference of 2.066529 secs
> 
> pdf(file='sir.pdf')
> 
> plot(x[[1]],variables=c("S","I","R","cases","W"))
> 
> t1 <- seq(0,4/52,by=1/52/25)
> X1 <- simulate(po,params=log(params),nsim=10,states=TRUE,obs=TRUE,times=t1)
Warning message:
The default behavior of 'simulate' has changed.
See the documentation ("pomp?simulate") for details
and set the 'times' and 't0' arguments appropriately to compensate.
 
> 
> t2 <- seq(0,2,by=1/52)
> X2 <- simulate(po,params=log(params),nsim=1,states=TRUE,obs=TRUE,times=t2)
Warning message:
The default behavior of 'simulate' has changed.
See the documentation ("pomp?simulate") for details
and set the 'times' and 't0' arguments appropriately to compensate.
 
> 
> t3 <- seq(0,20,by=1/52)
> tic <- Sys.time()
> X3 <- trajectory(po,params=log(params),times=t3,hmax=1/52)
Warning message:
The default behavior of 'trajectory' has changed.
See the documentation ("pomp?trajectory") for details
and set the 'times' and 't0' arguments appropriately to compensate.
 
> toc <- Sys.time()
> print(toc-tic)
Time difference of 4.560865 secs
> plot(t3,X3['I',1,],type='l')
> 
> f1 <- dprocess(
+                po,
+                x=X1$states[,,31:40],
+                times=t1[31:40],
+                params=matrix(
+                  log(params),
+                  nrow=length(params),
+                  ncol=10,
+                  dimnames=list(names(params),NULL)
+                  ),
+                log=TRUE
+                )
> print(apply(f1,1,sum),digits=4)
 [1] -51.57 -43.19 -50.14 -39.65 -41.63 -49.34 -39.60 -48.19 -42.60 -48.26
> 
> g1 <- dmeasure(
+                po,
+                y=rbind(reports=X1$obs[,7,]),
+                x=X1$states,
+                times=t1,
+                params=matrix(
+                  log(params),
+                  nrow=length(params),
+                  ncol=10,
+                  dimnames=list(names(params),NULL)
+                  ),
+                log=TRUE
+                )
> print(apply(g1,1,sum),digits=4)
 [1]   -Inf   -Inf   -Inf   -Inf   -Inf   -Inf -263.6 -408.1   -Inf -468.1
> 
> h1 <- skeleton(
+                po,
+                x=X2$states[,1,55:70,drop=FALSE],
+                t=t2[55:70],
+                params=as.matrix(log(params))
+                )
> print(h1[c("S","I","R"),,],digits=4)
      [,1]     [,2]     [,3]     [,4]     [,5]   [,6]   [,7]   [,8]   [,9]
S  39362.0  39111.6  39195.1  38583.3  38374.5  36367  34769  33057  29765
I    272.3    376.1    407.8    615.6    731.6   1423   2046   2755   4083
R -39640.5 -39495.0 -39609.9 -39205.0 -39112.3 -37796 -36819 -35816 -33852
   [,10]  [,11]  [,12]    [,13]  [,14]  [,15]  [,16]
S  24577  17622  11393    319.5 -14707 -33518 -57305
I   6165   8975  11503  15834.2  21418  27852  34849
R -30746 -26601 -22900 -16156.5  -6714   5662  22453
> 
> ## now repeat using the compiled native codes built into the package
> data(euler.sir)
> po <- euler.sir
> 
> set.seed(3049953)
> ## simulate from the model
> tic <- Sys.time()
> x <- simulate(po,nsim=100)
> toc <- Sys.time()
> print(toc-tic)
Time difference of 2.543359 secs
> plot(x[[1]],variables=c("S","I","R","cases","W"))
> 
> t3 <- seq(0,20,by=1/52)
> tic <- Sys.time()
> X4 <- trajectory(po,times=t3,hmax=1/52)
Warning message:
The default behavior of 'trajectory' has changed.
See the documentation ("pomp?trajectory") for details
and set the 'times' and 't0' arguments appropriately to compensate.
 
> toc <- Sys.time()
> print(toc-tic)
Time difference of 0.726177 secs
> plot(t3,X4['I',1,],type='l')
> 
> g2 <- dmeasure(
+                po,
+                y=rbind(reports=X1$obs[,7,]),
+                x=X1$states,
+                times=t1,
+                params=matrix(
+                  c(log(params),nbasis=3,degree=3,period=1),
+                  nrow=length(params)+3,
+                  ncol=10,
+                  dimnames=list(c(names(params),"nbasis","degree","period"),NULL)
+                  ),
+                log=TRUE
+                )
> print(apply(g2,1,sum),digits=4)
 [1]   -Inf   -Inf   -Inf   -Inf   -Inf   -Inf -263.6 -408.1   -Inf -468.1
> 
> h2 <- skeleton(
+                po,
+                x=X2$states[,1,55:70,drop=FALSE],
+                t=t2[55:70],
+                params=as.matrix(c(log(params),nbasis=3,degree=3,period=1))
+                )
> print(h2[c("S","I","R"),,],digits=4)
      [,1]     [,2]     [,3]     [,4]     [,5]   [,6]   [,7]   [,8]   [,9]
S  39362.0  39111.6  39195.1  38583.3  38374.5  36367  34769  33057  29765
I    272.3    376.1    407.8    615.6    731.6   1423   2046   2755   4083
R -39640.5 -39495.0 -39609.9 -39205.0 -39112.3 -37796 -36819 -35816 -33852
   [,10]  [,11]  [,12]    [,13]  [,14]  [,15]  [,16]
S  24577  17622  11393    319.5 -14707 -33518 -57305
I   6165   8975  11503  15834.2  21418  27852  34849
R -30746 -26601 -22900 -16156.5  -6714   5662  22453
> 
> print(max(abs(g2-g1),na.rm=T),digits=4)
[1] 0
> print(max(abs(h2-h1),na.rm=T),digits=4)
[1] 8.731e-11
> 
> states(po)[,1:2]
               [,1]          [,2]
S      4.531800e+04  4.511300e+04
I      2.038000e+03  2.020000e+03
R      2.052647e+06  2.052886e+06
cases  1.045000e+03  9.960000e+02
W     -2.334331e-01 -2.382536e-02
> time(po) <- seq(0,1,by=1/52)
> states(po)[,1:3]
      [,1]          [,2]          [,3]
S       NA  4.531800e+04  4.511300e+04
I       NA  2.038000e+03  2.020000e+03
R       NA  2.052647e+06  2.052886e+06
cases   NA  1.045000e+03  9.960000e+02
W       NA -2.334331e-01 -2.382536e-02
> states(simulate(po))[,1:3]
         [,1]          [,2]          [,3]
S       45500  4.528700e+04  4.497600e+04
I        2100  2.062000e+03  2.121000e+03
R     2052400  2.052647e+06  2.052876e+06
cases       0  1.007000e+03  1.041000e+03
W           0 -1.602887e-01 -1.965854e-01
> 
> po <- window(euler.sir,start=1,end=2)
> plot(simulate(po))
> timezero(po)
[1] 0
> timezero(po)<-2*time(po)[1]-time(po)[2]
> plot(simulate(po))
> 
> dev.off()
null device 
          1 
> 
> 
